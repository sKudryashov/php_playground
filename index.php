<?php
/**
 * 
 Подробнее  вот здесь http://ru.wikipedia.org/wiki/Двоичная_система_счисления
 * Перевод из двоичной системы в десятичную и наоборот здесь http://math.semestr.ru/inf/index.php
 * 
Вариант 1
512 	256 	128 	64 	32 	16 	8 	4 	2 	1
				1 	1 	0 	0 	0 	1
				+32 	+16 				+1

Точно так же, начиная с двоичной точки, двигайтесь справа налево. 
Под каждой двоичной единицей напишите её эквивалент в строчке ниже. 
Сложите получившиеся десятичные числа.
Таким образом, двоичное число 110001 равнозначно десятичному 49. 

Перевод целых чисел методом Горнера Для того, чтобы преобразовывать 
числа из двоичной в десятичную систему данным методом, надо суммировать 
цифры слева направо, умножая ранее полученный результат на основу 
системы (в данном случае 2). Например, двоичное число 1011011 переводится 
в десятичную систему так: 
0*2+1=1 >> 1*2+0=2 >> 2*2+1=5 >> 5*2+1=11 >> 11*2+0=22 >> 22*2+1=45 >> 45*2+1=91 
То есть в десятичной системе это число будет записано как 91. 
Или число 101111 переводится в десятичную систему так: 
0*2+1=1 >> 1*2+0=2 >> 2*2+1=5 >> 5*2+1=11 >> 11*2+1=23 >> 23*2+1=47 
То есть в десятичной системе это число будет записано как 47. 

Перевод дробных чисел методом Горнера 1) 0,11012=0,X10 (рассматриваем цифры в обратном порядке)
1:2=0,5
0,5+0=0,5
0,5:2=0,25
0,25+1=1,25
1,25:2=0,625
0,625+1=1,625
1,625:2=0,8125
Ответ: 0,11012= 0,812510
 * 
 * 
Преобразование десятичных чисел в двоичные

Допустим, нам нужно перевести число 19 в двоичное. Вы можете воспользоваться следующей процедурой :

19 /2 = 9  с остатком 1
9  /2 = 4  c остатком 1
4  /2 = 2  без остатка 0
2  /2 = 1  без остатка 0
1  /2 = 0  с остатком 1
Итак, мы делим каждое частное на 2 и записываем остаток в конец двоичной записи. 
Продолжаем деление до тех пор, пока в частном не будет 0. Результат записываем справо налево. 
Т.е. нижнее число будет самым левым и.т.д. В результате получаем число 19 в двоичной 
записи: 10011.


/**
 * Побитовые операции
 */
// подробнее в bit_operations.php
//х >> b (сдвиг вправо) - сдвигаются биты (разряды) левого операнда х вправо 
//на число позиций, указанных правым операндом b. Биты, сдвигаемые за 
//правый предел левого операнда, теряются. Для чисел типа unsigned 
//(положительные, без знака) позиции, освобождающиеся слева, 
//заполняются нулями. Для чисел со знаком освобождающиеся позиции могут заполняться 
//значением знакового разряда (самого левого), поэтому лучше всего предварительно 
//преобразовать операнд в беззнаковый тип.

//Операции сдвига применяются для умножения или деления исходного опе­ранда на 
//степень двух, т.е. х << n эквивалентно умножению х на 2n, а 
//х >> n эквивалентно делению на 2n, если это число неотрицательно.

// PHP Basics 
error_reporting(E_ALL);

$i = 0;
$a = null;
 while($i<5)
 {
 	$a = ++$i; // !! здесь идет сначала действие инкремента, а потом присваивания              
 	$test_cycle =  "\n проверка цикла \$a = $a \$i++"; 
 } 
 $i = 0;
 $a = null;
 while($i<5)
 {
 	$a = $i++; //!! здесь идет сначала действие присваивания, а потом инкремента            
 	$test_cycle =  "\n проверка цикла \$a = $a \$i++"; 
 }


/**
 * Тест из книжки 5.3
 */
$a = 1;
++$a;
$a *= $a;
$z = $a--; // ага. Здесь $z = 4 а $a = 3; то есть действие декремента идет после присвоения
$m = --$a; // здесь $m = 2 и $a = 2;  - то есть то где расположен знак инкремента - декремента - оно же влияет.
            // причем не только в цикле

$is = empty($zoop); //true - сообщ об ошибке нет

$zoop = '';
$is_str = empty($zoop); // true

$zoop = 0;
$is_zero = empty($zoop); //true

$zoop = null; 
$is_null = empty($zoop); //true

$zoop = '0';
$is_string_zero = empty($zoop); //true

$zoop = false;
$is_bool = empty($zoop); //true

$zoop = 'false';
$is_bool_string = empty($zoop); //false

$a = 0;
$b = null; // да. В этом случае НЕ вылетит нотайс, что $b undefined variable
while($a < 5){
    $b .= "$a,"; //0,1,2,3,4,
    $a++;
}


$a=0;
$b = null;
while($a<5){
    $b .= "$a,"; // 0,1,2,3,4,
    ++$a;
}

$b = null;
for($i = 0; $i < 5; $i++){
    $b .= "$i,"; // 0,1,2,3,4,
}

$b = null;
for($i = 0; $i < 5; ++$i){
    $b .= "$i,"; //0,1,2,3,4,
}


$a = 1;
if($a == true)
{
	echo 'la';
} 


function getName()
{  
  $file = fopen ("count.txt","r+");  
  if (!$file)
  {
    echo("file cant be open");
  }
  else
  {
  	
  	$count = fread($file, 5);
  	$count++;
  	
  }  
  fclose ($file);
  
  
  $file = fopen ("count.txt","w+");
  if ( !$file )
  {
    echo("file cant be open");
  }
  else
  {
    fputs ($file, $count);
  }  
  fclose ($file);
  return $count;    
}

getName();

/**
 * Cкалярные данные в php их всего 4
 * boolean 
 * int 
 * float
 * string
 * 
 * кстати E в как экспонента - case insentitive
 * кстати на 64 битной платформе может быть более широкий диапазон целых значений
 * 
 * Объединенные типы данных:
 * Объект
 * Массив
 * 
 * Осталные типы данных:
 * NULL
 * resource
 * 
 * всего 8
 */ 

echo 1; 
# this is a codeblock ?>
echo 2;
?>
<?php 
echo "<h1> PHP Basics</h1> " ;
$a = print('a');
echo ("\n status:".$a);
 echo "<br>";
 $r =  2e3; /// экспонента - означает 2000
 echo '<br>';
 $r1 =  (int) ((0.1 + 0.7)*10); // float не всегда способен представить числа в том виде, в котором мы ожидаем
                              // к примеру пример выше выведет 7 а не 8, по причине того что результат вычислений
                              // внутри php хранится как 7.99999999, а int обрезает все то, что после запятой
                              // поэтому лучше использовать BCMath функции
 echo "\n value is boolean:";
 $zero = (boolean) '0'; // приведение к булеву - если 0 то false. если что то кроме 0
                        // даже множество нулей то true. конкретно эта строка false
                        // несмотря на то что 0 здесь - строковое значение
 echo $zero;
 
 /**
  * Кстати мы можем конвертнуть resource в int - получим число идентификатор ресурса
  * и в строку - получим строку resource
  * 
  * Переменные - как и константы чувствительны к регистру
  */
 if ($zero)
 {
 	echo 'true';
 }
 else
 { 
 	echo 'false';
 }
 
 $test_str_zero = '0';
 if($test_str_zero){ // строковый 0 тоже false
     echo "\n test zero string_0 is true";
 }else{
     echo "\n test zero_string_0 is false";
 }
 
 $str_test_false = 'false';
 if($str_test_false){ // строковый false это true
     echo "\n test false_string true \n";     
 }else{
     echo "\n test false_string false \n";
 }

 $a = false;
 $b = ($a) ? 'true'  :  'false'; 
 echo " \n string false $b";
 
 echo "<br> Brackets block {}: ";
 
 $name  = 123;
 
 $$name = 456;
 $not_reference = '111';
 echo ${'123'};
 $e = ${'123'}; // $e = 456
 echo '<br> test brackets_ not reference: ';
 $r3 =  ${'not_reference'}; // выведет 111
 echo "<br> test isset null variable :"; 
 $a = null;
 $r4 = ((isset($a))?'true':'false'); // return false 
 
 echo "<br>test defining constant constant"; //
 define('CONST1',2);
 echo CONST1;
 
 echo "<br> цикл i++ и ++i";
 $i=0;
  
 $a = "Tesssaasast";
 $c = 'one word';
 $b = $a + 28; // $b = 28
 $a++; // $a = Tesssaasasu
 echo '<br>РµС‰Рµ:'.$a. " && b ". $b . '&& c: '. ++$c ; // $c = one wore - короче 
                                                //последняя буква увеличивается в алфавите на 1
                                                // и из d получается e - след буква, после д. т.е. ++
                                                      
 $x = -5;
 $a = ~$x;  // $a = 4 - что за оператор такой? - ага это оператор битовых операций - работает только с целыми числами
 $x = 0;
 $a = ~$x; // побитовый сдвиг что ли
 
 $x1 = 3;
 $a1 = ~$x1; // короче меняет знак и прибавляет по модулю 1
 
 $x2 = 34;
 $a2 = ~$x2;
 
 echo $a;
 
 $a = true ; $b = true;
 
 if($a ^ $b) 
 {
 	echo " & true";
 } 
 else 
 {
    echo "& false"; // XOR или - или. то есть здесь false
 } 
 
 // TODO:// разобраться с побитовыми сдвигамиlf , хз как оно работает
 $x = 1; 
 $r4 = $x << 32;  //$r4 = 1
 
 $x1 = 14; 
 $r5 = $x1 << 32; //$r5 = 14
 
 $x3 = 14; 
 $r5 = $x3 << 32; //$r5 = 14 - 
 
 
 $variable = 'vovan ';
 $variable +=3; //  $variable = 3
   
 $a = 10 ; 
 $b = 20 ; 
 $b = &$a; 
 $b = 30; 
 echo "\n a = $a ; $b = $b";
 $b +=1;
 unset ($a); // $a разустановлено, $b все еще 31
 
 // проверка второго случая передачи по ссылке 
 $a = 10 ; 
 $b = 20 ; 
 $b = &$a; 
 $b = 30; 
 echo "\n a = $a ; $b = $b";
 $b +=1;
 unset ($b); // $b разустановлено, $b все еще 31
 
 echo "\n a = $a ; $b = $b"; 
 
 unset ($b);
 echo " a = $a ; $b = $b";
 // !В обеих случаях, ВНЕ зависимости от порядка разустановки $a или $b 
 // скрипт работает одинаково, то есть нужно сделать unset И для a и для b
   
 $a = (int) 1;
 $b = (string) 1;
 
 if($a !== $b)
 {
 	echo "<br> true"; // не эквивалентно - попадаем сюда
 }
 $a = 'Abc';
 $b = 'abc';
if($a < $b) {// здесь $a и правда > $b т.е. $r5 = true
    $r5 = true;
} // здесь то же самое - с таблицей кодов ASCII

$left = "ABC";
$right = "ABD";
echo (int) ($left > $right); // выведет 0. Причина - в таблице кодов ASCII D стоит выше чем С
 

$a = `cd /home/serhio`; // системный вызов linux в кавычках `` $q = null
  
 echo "<br> a : $a";
 
 echo (true)?'yes':'no';

 $i=$a=0;
 
 // здесь при таком цикле мы вообще не попадаем в него
 while (false){
 	$i++;
 	echo "<br>while : $i"; 
 } 
 
 // а при таком - одна итерация все таки есть :)
 do {
 	$a++;
 	echo "<br> d0 while : $a";
 } while (false); 
 
 /**
  * Кстати в php операторы сравнения, все кроме ! бинарные а ! унарный. И  в php
  * все логические операторы работают с булевым типом, то есть срабатывает здесь 
  * автоприведение
  */
 // кстати операторы & и && работают по разному. Если в && левый операнд FALSE - 
 // то он не проверяет правый. А & проверяет. 
 $a = array('q'=>'quit', 'e'=>'enter');
 
 if(isset($a['u']) && $a['u'] == 'quit'){ // в этом случае notice НЕ вылетает
     echo "\n условие с &&";
 }else{
     echo "\n нет условия с &&";
 }
 
 if(isset($a['v']) & $a['v'] == 'quit'){ // в этом случае вылетает notice
     echo "\n условие с &";
 }else{
     echo "\n нет условия с &";
 }
 
 /**
  * Приоритет и ассоциативность операторов
  */
 // короче в таблице приоритетов те операции что выше - имеют более высокий приоритет,
 // но принудительно указать приоритет можно в скобках.
 
 // По выходу из цикла кстати
 
 for ($i = 1; $i < 10; $i++){
     for($j=1; $j<10; $j++){
         if($i == $j){
             break 2; // вот здесь мы сразу выходим из двух циклов выполнения, первого и второго.
         }
         else{
             continue; // оператор перехода на следующую итерацию 
         }
     }
 }

 /**
  *  типы ошибок в php 
  * Compile-time errors ошибки компиляции - не могут быть пойманы
  * Fatal errors фаталы - не могут быть пойманы
  * Recoverable errors - непонятно из описания - что, но могут быть отловлены
  * Warnings 
  * Notices - оба этих типа знакомы и могут быть отловлены
  */
 //error_reporting=E_ALL & ~E_NOTICE все ошибки ИСКЛЮЧАЯ нотайсы
 
 // стоит также помнить о замечательной функции set_error_handler
 // и знать, о том что даже в случае подавления ошибки @ все равно
 // эти ошибки будут валиться в хендлер. Это они просто в скрипте не выводятся.
 
 $a = testCalling(102); // пофиг даже если функция внизу - она все равно вызовется.
 
 function testCalling($param)
 {
     return $param;
 }

 $ff = set_error_handler('myHandler', E_ALL); 
 //// правильное объявление, при E_ALL & ~E_NOTICE мы сюда не попадаем, в хендлер
 // код нужен 30719 или в виде константы E_ALL (это ж константа тоже) - сработало
 function myHandler($errNo, $errStr, $errFile, $errLine, $errContext)
 {
     return array($errNo, $errStr, $errFile, $errLine, $errContext);
 }
  $a = array();
 $b = $a['stuff'];
 $c = @$a['megazoid']; // даже подавление ошибки не спасает от попадания в хендлер, что в общем логично
 

?>