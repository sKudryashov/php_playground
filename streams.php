<?php

/**
 * streams  chapter
 *
 * @author Kudryashov Sergey iden.82@gmail.com
 */
//Есть два основных типа потоков в php - одна группа предоставляет доступ 
//к определенному типу ресурсов потока, стандартная поставка php включает
//несколько встроенных примеров, как ниже
//• php.* - стандартный поток ввода вывода 
//• file - стандартный доступ к файлу
//• http - доступ к ресурсу по http
//• ftp - доступ к ресурсу по ftp
//compress.zlib - доступ к сжатому потоку данных с использованием zlib сжатия
//
//в дополнение к этому некоторые потоковые расширения могут быть заинсталлированы
//а также цепочки фильтров, которые действуют на поток данных:
//• string.rot13 - кодирует поток данных с использованием ROT13 алгоритма
//• string.toupper—конвертит строку в верхний регистр
//• string.tolower—конвертит строку в нижний регистр
//• string.strip_tags—удаляет xml теги из потока
//• convert.*—семейство фильтров что кодирует в и из кодировки base64
//• mcrypt.*— семейство фильтров которое кодирует и декодирует строку 
//  в соответствии с разными криптоалгоритмами 
//• zlib.*—семейство фильтров которые сжимают и разжимают данные используя zlib либу

// потоки данных возможно оборачивать в соответствующие фильтры. Хотя эти пользовательские 
// потоки и фильтры могут занять целую книгу, типа их много
//хендлер файла это всего лишь ссылка на файл, сам файл целиком не грузится в память, 
//что довольно ресурсодружественно

//начнемс 
$fh = fopen('streams/file.txt', 'a+');
if($size = filesize('streams/file.txt')){
    echo 'file is empty';
}
else{
    $counter = (int) fgets($fh); //возвращает линию на которой стоит указатель конца файлв
}
$st = ftruncate($fh, 0); // обрезает файл до требуемой длины (return type bool)
$counter++;
$st = fwrite($fh, $counter);

//Список флагов для fopen:
//r  -открывает файл только для чтения и ставит указатель в начало файла
//r+ -открывает файл для чтения и записи и ставит указатель в начало файла
//w  -открывает файл только для записи, ставит указатель в начало файла и обрезает его до нулевой длины
//    если файла нет - пытается создать его
//w+ -открывает файл для записи и чтения и ставит указатель в начало файла и обрезает его до нулевой длины
//    если файла нет - пытается создать его
//a  - открывает файл только для записи и ставит указатель в конец файла 
//    если файла нет - пытается создать его
//a+ - открывает файл для чтения и записи и ставит указатель в конец файла
//    если файла нет - пытается создать его
//x  - создает файл только для записи 
//x+ - создает файл для чтения и записи 
//каждый из этих режимов может быть связан с модификатором который обозначает - как данные могут читаться
//и писаться. Например b флаг (эквивалентно w+b) включает бинарный режим который дает уверенность в том
//что данные записываются в файл неизмененными, есть также чисто windows флаг t который 
//транслирует юниксовые символы новой строки \n в виндовые символы новой строки \r\n
//Режимы w w+ a a+ если файла нет - пытаются создать его. 
//Напротив если используется режим x или x+ а файл с таким названием существует, то будет 
//выброшен E_WARNING

// общие С - похожие файловые функции:
$ff = feof($fh); //определеяет - добрался ли внутренний указатель до конца файла
$fe = file_exists('streams/file.txt');

$txt = '';
while(!feof($fh)){
    $txt .= fread($fh, 1); // читает length байт из указателя файла, на который ссылается fh. 
                           // Чтение останавливается, если прочитано length байт или попадает на 
                           // конец файла. То есть fread читает весь файл целиком в 
                           // то время как fgets построчно
}
// нужно заметить что использование file_exists() возвращает true в том случае, 
// если файл виден для того пользователя под которым находится сам php интерпретатор
// указатель файла может быть передвинут сам по себе и без операции чтения/записи
// с помощью fseek 
$st = fseek($fh, 5, SEEK_SET);
// первый параметр это файловый хендлер - второй это количество байт на которое будет
// произведено смещение - третий параметр - здесь могут быть три варианта:
// SEEK_SET - с начала файла 
// SEEK_CUR - c существующей позиции
// SEEK_END - c конца файла

//Стоит иметь ввиду что значение второго параметра (величины смещения) добавляются 
//к позиции которую мы обозначили как стартовая точка. Следовательно если мы 
//ставим SEEK_END третьим параметром то второй параметр должен быть или 0 или меньше
//Если используем SEEK_CURRENT третьим то вторым параметром может быть как положитель-
//ное так и отрицательное значение (смещение вперед и назад соответственно). МОжно и ноль
//- это легально но не имеет смысла

$pos = ftell($fh); // чтобы получить конкретную позицию указателя - в данном случае 5  

$st_ = is_file('streams/file_csv.txt');
$st = is_readable('streams/file_csv.txt');
$fcsv = fopen('streams/file_csv.txt', 'a+');

$csv_file = fgetcsv($fcsv); // упрощает чтение csv файла 
//пример fgetcsv(handle, length, delimiter, enclosure, escape)
// length - длина чтения
// delimiter - разделитель (для csv ; обычно) 
// enclosure - Символ-ограничитель enclosure это двойная кавычка, если иной не специфицирован
// escape - ескейп символ, бэкслеш по дефолту

$str_data = '';
while($data = fgetcsv($fcsv)){ //1 итер array(3) ([0] => one element [1] => two element  [2] => third element )
    $str_data .= $data;
}
$arr = array('one element', 'two element', 'third element', 'f'=>'four el');
$st = fputcsv($fcsv, $arr, ';'); // возвращает кол-во эл-тов очевидно (44) 
// Пишет вот что: "one element";"two element";"third element";"four el"
// в самом файле получилось: 
/* jj;00
"one element","two element","third element"
 * Хотя должно было по идее
 * 0;one element
 * 1;two element
 * Хотя все правильно. Странно но в php.net тоже так.
 * Если задать многомерный массив, то в файл попадет конструкция вида array array
 */

// если мы не обозначили delimiter и enclosure символ то обеими fputcsv и fgetcsv
// будет использоваться в качестве delimiter и enclosure используются запятая и кавычки
// соответственно. что то типа "ключ","значение"

// Не C-like но тоже хорошие  функции))

header("Сontent-type: video/mpeg");
// чтение файла и вывод его в стандартный поток вывода
readfile("my_home_movie.mpeg");

// читает файл в массив где каждая строка файла становится элементом массива
$r = file('streams/file_csv.txt');

// чтобы прочесть файл в строку был старый способ в php4
$file = implode("\r\n", file('streams/file_csv.txt'));

// но слава богу есть и более  человеческий способ
$file = file_get_contents('streams/file_csv.txt');

// загрузка целиком всего файла в память это не всегда хорошая идея кстати, особенно если файл
// большой а нагрузка предвидится ничего себе
// 
// обратная функция - запись строки в файл
$data = array("More Data", "And More", "Even More");
file_put_contents('streams/file.txt', $data); // здесь запишется как More DataAnd MoreEven More
/*
 * Врозможные опции для нее: 
 * FILE_USE_INCLUDE_PATH - использовать include_path
 * FILE_APPEND - добавлять строку а не перезаписывать
 * LOCK_EX - эксклюзивная блокировка перед доступом к файлу
 * 
 * Нужно обратить внимание что мы записываем массив. В этом случае автоматически будет 
 * вызвано действие implode("",$data) и результат работы этой функции будет записан в файл
 * Также интересное поведение будет, если передать в нее хендлер открытого файла, в этом случае
 * "непрочитанный оставшийся поток будет записан в файл"
 */
// попробуем скормить ему хендлер csv файла
file_put_contents('streams/file.txt', $fcsv, FILE_APPEND); // а вот если дать ему хендлер файла 
//то ничего не запишется

//TODO: еще нужно будет отработать set_include_path(); и get_include_path();
echo '<br> <br> <br> <br>';
$incl_p = get_include_path();
$st = set_include_path($incl_p.':'.'/home/serhio/www/php5certification.my/www/streams');
// Да, это работает, как я и предполагал, но только для таких функций и операторов как:
//require() include(), fopen(), file(), readfile() and file_get_contents()
//причем php сначала смотрит первый путь до разделителя ":", если файл в нем не найден, 
//он ищет по второму пути и пр.. если не находит, то в зависимости от оператора может 
// выбросить warning. Кстати если мы ставим точку перед началом пути, то php проверяет текущую директорию
// правда зачем это нужно я не совсем понял
$incl_p = get_include_path();
$is = readfile('file.txt'); // пока false
$cwd = getcwd(); // получить current working dir
//$is2 = is_file('/home/serhio/www/php5certification.my/www/streams/folder1/folder2/zoolok.txt');
require('zoolok.txt');
echo 'once again chief';
require_once('zoolok.txt');
$incl_p = get_include_path();
$succ = chdir('streams'); // само собой что если у интерпретатора нет прав, то мы сюда не попадем
$cwd = getcwd(); // получить текущую рабочую директорию, что интересно - в некоторых unix системах 
                // если какая нибудь родительская директория не имеет соотв прав просмотра для 
                // скрипта, то getcwd  может вернуть false 

/**
 * Отдельная история с циклом while и is_readable
 * если файл не is_readable и в процессе выполнения цикла он станет readable 
 * то мы об этом не узнаем, если не применим очистку внутри кэша php
 */
$file = 'somefile.txt'; // файл без права на чтение
while(!is_readable($file)){
    
    echo 'do something..';
    chmod($file, 777); // все равно мы попадем в бесконечный цикл, если не включим
    // кстати правда в chmod должны задаваться ИСКЛЮЧИТЕЛЬНО в виде цифр
    clearstatcache();    
}
//Доступ к сетевым ресурсам:
//в наиболее простых случаях - такой же как и к файлам
// например
$f = fopen ('http://www.phparch.com');
$page = '';
if ($f) {
    while ($s = fread ($f, 1000)) {
    $page .= $s;
    }
} else {
    throw new Exception ("Unable to open connection to www.phparch.com");
}
//конечно же не все файловые функции будут работать с сетями, например функции 
//записи не будут - это бессмысленно
// кстати в зависимости от настроек php мы также можем делать require или include сетевых ресурсов 
// типа include ’http://phparch.com’; хотя конечно с точи зрения безопасности это как то и не очень..
// потоковые контексты - создаются с помощью stream_create_context():
$http_options = stream_context_create(array(
'http' => array(
'user_agent' => "Davey Shafiks Browser",
'max_redirects' => 3
)
));
$file = file_get_contents("http://http://www.php5certification.my/streams.php", false, $http_options);

/**
 * Похожие функции 
 * 
 stream_socket_server() - Create an Internet or Unix domain server socket
 stream_socket_get_name() - Retrieve the name of the local or remote sockets
 stream_set_blocking() - Set blocking/non-blocking mode on a stream
 stream_set_timeout() 
 * 
 * В работе с сокетами со стороны сервера возможен блокирующий и не блокирующий режим.
 * который устанавливается функцией stream_set_blocking ( resource $stream , int $mode )
 * Это касается ф-ций fgets() и fread(), которые читают из потока
 * В неблокирующем режиме fgets вызов возвращает данные сразу в то время как 
 * в блокирующем он ждет, пока данные станут доступны для потока.
 * Еще замечание с php.net: 
 * When you use fwrite() on a non-blocking stream, data isn't discarded silently as t dot starling said.
 */

// в общих случаях этого достаточно, но бывают более сложные взаимодействия с сетью, 
// где имеет смысл сработать через сокеты stream_socket_server() и stream_socket_client()

// на стороне сервера создаем сокет
$socket = stream_socket_server("tcp://0.0.0.0:1037");
while ($conn = stream_socket_accept($socket)) {
    fwrite($conn, "Hello World\n");
    fclose($conn);
}
fclose($socket);

// потом мы к этому сокету можем приконнектиться используя stream_socket_client
// вообще конечно надо бы разнести по отдельным файлам и проверить но пока поверим 
// на слово
$socket = stream_socket_client('tcp://0.0.0.0:1037');
while (!feof($socket)) {
    echo fread($socket, 100);
}
fclose($socket);

// пример использования потоковых фильтров
$socket = stream_socket_server("tcp://0.0.0.0:1037");
while ($conn = stream_socket_accept($socket)) {
    stream_filter_append($conn, 'string.toupper');// назначили фильтр верхнего регистра
    stream_filter_append($conn, 'zlib.deflate');// назначили фильтр сжатия потока
    fwrite($conn, "Hello World\n");
    fclose($conn);
}
fclose($socket);

// а на клиенте как то так:
$socket = stream_socket_client('tcp://0.0.0.0:1037');
stream_filter_append($socket, 'zlib.inflate'); //назначили фильтр разжатия
while (!feof($socket)) {
    echo fread($socket, 100);
}
fclose($socket);
// как мы можем видеть - потоки предоставляют более глубокий уровень доступа, 
// такой как tcp и udp сокеты. МОжно даже создавать свои фильтры сжатия, криптования
//  и даже, как пишут, свои протоколы 