var n = 2; 
n.toPrecision(3);// 3 знака после запятой 
var product = "21" * "2";// в результате получится число 42.
var number = string_value - 0; // приведение к нулю
var number = Number(string_value);//Недостаток такого способа преобразования строки 
                                //в число заключается в его//чрезмерной строгости. 
                                //Этот способ может использоваться только для преобразо
                                //вания десятичных чисел, и хотя он допускает наличие 
                                //ведущих и оконечныхсимволов пробела, появление 
                                //других нецифровых символов после числа в строке
                                //недопустимо.
parseInt("3 слепых мышки"); // 3
parseFloat("3.14 метров"); //3.14
parseInt("12.34"); //12
parseInt("0xFF"); //255
//В качестве второго аргумента функция parseInt() может принимать основание
//системы счисления. Корректными значениями являются числа в диапазоне от 2
//до 36, например:
parseInt("11", 2); // Вернет 3 (1*2 + 1)
parseInt("ff", 16); // Вернет 255 (15*16 + 15)

//Если методы parseInt() и parseFloat() оказываются не в состоянии выполнить
//преобразование, они возвращают значение NaN:
parseInt("eleven");// Вернет NaN

//Если вы предпочитаете выполнять преобразование явно, можно воспользовать
//ся функцией Boolean():
var x_as_boolean = Boolean('12'); // true - любое число кроме 0 и NaN = true
var s = (NaN == NaN); // false.
 
//Поскольку функции представляют собой значения, такие же, как числа и стро
//ки, они могут присваиваться свойствам объектов
var square = function(x) { return x*x; } // Лямбда функция

//Имеется еще один способ определения функции: можно передать список аргу
//ментов и тело функции в виде строк в конструктор Function(). Например:
var square = new Function("x", "return x*x;"); // но это не очень удобно

// обычный вызов
var o = new Object();
var now = new Date();
var pattern = new RegExp("\\sjava\\s", "i");

//Наконец, значениями свойств в объектных литералах не обязательно должны
//быть константы – это могут быть произвольные JavaScript выражения. Кроме
//того, в качестве имен свойств в объектных литералах допускается использовать
//строковые значения:
var square = { "upperLeft": { x:point.x, y:point.y },
'lowerRight': { x:(point.x + side), y:(point.y+side) }};

//Когда непустой объект используется в логическом контексте, результатом преоб
//разования является значение true

//Когда объект используется в строковом кон
//тексте, преобразование выполняется методом toString()

//Когда объект используется в числовом контексте, сначала вызывается метод объекта valueOf().
//Если этот метод возвращает числовое значение примитивного типа, в дальней
//ших вычислениях участвует это значение. Однако в большинстве случаев метод
//valueOf() возвращает сам объект. В такой ситуации объект сначала преобразует
//ся в строку вызовом метода toString(), а затем выполняется попытка преобразо
//вать строку в число.

//МАССИВЫ
var a = new Array();
a[0] = 1.2;
a[3] = { x:1, y:3 }; // два эл-та 0 и 3
var a = new Array(1.2, "JavaScript", true, { x:1, y:3 }); //тоже вариант
var a = new Array(10); //создает массив с 10 элементами
var sparseArray = [1,,,,5]; //Создает массив с 5 элементами, в т.ч. 3 пустых

//Обычно считается,что у значения null объектный тип и оно говорит об отсутствии объекта. Значе
//ние null уникально и отличается от любых других. Если переменная равна null,
//следовательно, в ней не содержится допустимого объекта, массива, числа, стро
//ки или логического значения.1
//Когда значение null используется в логическом контексте, оно преобразуется
//в значение false, в числовом контексте оно преобразуется в значение 0, а в стро
//ковом контексте — в строку "null".

//Еще одно специальное значение, иногда используемое в JavaScript, – undefined.
//Оно возвращается при обращении либо к переменной, которая была объявлена,
//но которой никогда не присваивалось значение, либо к свойству объекта, кото
//рое не существует. Заметьте, что специальное значение undefined – это не то же
//самое, что null.
//Хотя значения null и undefined не эквивалентны друг другу, оператор равенства == считает их равными.
// а вот оператор === позволяет отличать их. Также через typeof() тоже можно

//Если нельзя с уверенностью сказать, есть ли в данной реализации переменная
//undefined, можно просто объявить собственную переменную:
//var undefined;

//Когда значение undefined используется в логическом контексте, оно преобразует
//ся в значение false. В числовом контексте – в значение NaN, а в строковом –
//в строку "undefined".

var now = new Date(); // Создание объекта, в котором хранятся текущие дата и время.                                    
var xmas = new Date(2000, 11, 25);// номера месяцев начинаются с нуля декабрь имеет номер 11!
xmas.setFullYear(xmas.getFullYear() + 1); // Заменяем дату датой следующего Рождества.
var weekday = xmas.getDay();// В 2007 году Рождество выпадает на вторник.
document.write("Сегодня: " + now.toLocaleString()); // Текущие дата и время.

//Как и объект Date, объект RegExp не является одним из фундаментальных типов данных JavaScript; 
//это лишь стандартизованный тип объектов, предоставляемый всеми соответствующими
//реализациями JavaScript.
var st = /^HTML/; //- это объект RegExp;
var st = /[1 9][0 9]*/;
var st = /\bjavascript\b/i;

//Также есть объект Error и типы ошибок Заранее определены следующие типы объектов ошибок –
//Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError и URIError.

//Для каждого из трех базовых типов данных определен соответст
//вующий класс объектов. То есть помимо поддержки числовых, строковых и ло
//гических типов данных JavaScript поддерживает классы Number, String и Boolean.
//Эти классы представляют собой «обертки» для базовых типов данных. Обертка
//(wrapper) содержит такое же значение базового типа, но кроме этого определяет
//еще свойства и методы, которые могут использоваться для манипуляций с этим
//значением.

//Все объекты в js передаются по ссылке

//Сравниваются две ссылки, чтобы определить, ссылаются ли они на одно и то же
//значение. Ссылки на разные значения рассматриваются как неравные, даже ес
//ли сами значения совершенно идентичны.

// Функции передается ссылка на массив, а не копия массива.
// Благодаря этому функция может изменять содержимое массива, переданного
// по ссылке, и эти изменения будут видны после возврата из функции.
//function add_to_totals(totals, x)
//{
//totals[0] = totals[0] + x;
//totals[1] = totals[1] + x;
//totals[2] = totals[2] + x;
//}

//ЕШЕ РАЗ: Объекты, массивы и функции – это ссылочные типы.

//function add_to_totals2(totals, x)
//{
//newtotals = new Array(3);
//newtotals[0] = totals[0] + x;
//newtotals[1] = totals[1] + x;
//newtotals[2] = totals[2] + x;
//totals = newtotals; // Эта строка не оказывает влияния
// на массив за пределами функции
//}

//Переменные, объявленные с помощью инструкции var, называются долговре
//менными (permanent): попытка удалить их с помощью оператора delete приве
//дет к ошибке.

function test(o) {
    var i = 0; // i определена во всей функции
    if (typeof o == "object") {
    var j = 0; // j определена везде, а не только в блоке
    for(var k = 0; k < 10; k++) { // k определена везде, не только в цикле
        document.write(k);
    }
        document.write(k); // k все еще определена: печатается 10
    }
    document.write(j);    // j определена, но может быть не инициализирована
}

//В клиентском языке JavaScript в качестве глобального объекта для всего Java
//Script кода, содержащегося в соответствующем ему окне броузера, служит объ
//ект Window. Этот глобальный объект имеет свойство window, ссылающееся на сам
//объект, которое можно использовать вместо ключевого слова this для ссылки на
//глобальный объект.

//цепочка областей видимости
var a = 1;// Глоб область видимости

function b(){ // Глоб область видимости + область видимости функции b
    var b = 2;
    
    function c(){ // Глоб область видимости + область видимости ф-ции b и c
        var c = 3;
    }
}
//В Java Script все числа вещественные, поэтому результатом любого деления являет
//ся значение с плавающей точкой. Операция 5/2 дает 2.5, а не 2. Результат де
//ления на ноль – плюс или минус бесконечность, а 0/0 дает NaN.


var profit = +1000000; // то же что и 1000000
var profit = -1000000; // то же что и -1000000

//Например, следующий код делает переменные i = j = 2
//i = 1;
//j = ++i

//А этот устанавливает i = 2, а j = 1:
//i = 1;
//j = i++;

//• 85 Если оба значения равны null или undefined, то они идентичны.

//• Если одно из значений представляет собой объект, а другое – число или
//строку, объект преобразуется в элементарный тип и сравнение выполняет
//ся снова. Объект преобразуется в значение элементарного типа либо с по
//мощью своего метода toString(), либо с помощью своего метода valueOf().
//Встроенные классы базового языка JavaScript сначала пытаются выпол
//нить преобразование valueOf(), а затем toString(), кроме класса Date, кото
//рый всегда выполняет преобразование toString(). Объекты, не являющие
//ся частью базового JavaScript, могут преобразовывать себя в значения эле
//ментарных типов способом, определенным в их реализации.


//Оператор in требует, чтобы левый операнд был строкой или мог быть преобразо
//ван в строку. Правым операндом должен быть объект (или массив). Результатом
//оператора будет true, если левое значение представляет собой имя свойства объ
//екта, указанного справа. Например:
var point = { x:1, y:1 };
var has_x_coord = "x" in point; //Равно true
var has_y_coord = "y" in point; //Равно true
var has_z_coord = "z" in point; //Равно false; это не трехмерная точка
var ts = "toString" in point; //Унаследованное свойство; равно true

var d = new Date(); // Создаем новый объект с помощью конструктора Date()
var x = d instanceof Date; // Равно true; объект d был создан с помощью функции Date()
var x = d instanceof Object; //Равно true; все объекты представляют собой экземпляры Object
a = "2"; b = "2";
c = a + b; //c = 22
//Оператор + особенный, поскольку дает приоритет строковым операндам перед
//числовыми. Как уже отмечалось, если один из операндов оператора + представ
//ляет собой строку (или объект), то другой операнд преобразуется в строку (или
//оба операнда преобразуются в строки) и операнды конкатенируются, а не скла
//дываются.

1 + 2 //Сложение. Результат равен 3.
"1" + "2" //Конкатенация. Результат равен "12".
"1" + 2 //Конкатенация; 2 преобразуется в "2". Результат равен "12".
11 < 3 //Численное сравнение. Результат равен false.
"11" < "3" //Строковое сравнение. Результат равен true.

"11" < 3 // Численное сравнение; "11" преобразуется в 11. Результат равен false.
"one" < 3 // Численное сравнение; "one" преобразуется в NaN. Результат равен false.

//И наконец, важно заметить, что когда оператор + применяется к строкам и чис
//лам, он может быть неассоциативным. Другими словами, результат может зави
//сеть от порядка, в котором выполняются операции. Это можно видеть на следую
//щих примерах:
s = 1 + 2 + " слепых мышей"; // Равно "3 слепых мышей"
t = "слепых мышей: " + 1 + 2; // Равно " слепых мышей: 12"
//Причина этой удивительной разницы в поведении заключается в том, что опера
//тор + работает слева направо, если только скобки не меняют этот порядок. Следо
//вательно, последние два примера эквивалентны следующему:
s = (1 + 2) + "слепых мышей"; // Результат первой операции
t = ("слепых мышей: " + 1) + 2; // Результаты обеих операций число; второй строки


//Для объектов, массивов и (как ни странно) значения null результатом будет
//строка "object". Для операндов функций результатом будет строка "function",
//а для неопределенного операнда – строка "undefined".

//Как ни странно, стандарт ECMAScript определяет, что
//оператор delete также возвращает true, если его операнд не является свойством,
//элементом массива или переменной.) Далее приводится несколько примеров
//применения этого оператора:
var o = {x:1, y:2}; // Определяем переменную; инициализируем ее объектом
delete o.x;// Удаляем одно из свойств объекта; возвращает true
typeof o.x;// Свойство не существует; возвращает "undefined"
delete o.x;// Удаляем несуществующее свойство; возвращает true
delete o;// Объявленную переменную удалить нельзя; возвращает false
delete 1;// Нельзя удалить целое; возвращает true
x = 1;// Неявно объявляем переменную без ключевого слова var
delete x;// Этот вид переменных можно удалять; возвращает true
x;// Ошибка времени выполнения: x не определено

// Геттеры и сеттеры
//Свойствами объекта о являются:
//
//    o.a - число
//    o.b - getter, возвращающий o.a плюс 1
//    o.c - setter, устанавливающий значение o.a в половину его величины

var o = new Object;
o = {a:7, get b() {return this.a+1; }, set c(x) {this.a = x/2}};
var a = o.a; //7
var b = o.b // 8
o.c = 50
a = o.a //25



//Оператор void
//Унарный оператор void указывается перед своим единственным операндом, тип
//которого может быть любым. Действие этого оператора необычно: он отбрасывает 
//значение операнда и возвращает undefined. Чаще всего этот оператор применя
//ется на стороне клиента в URL адресе с признаком псевдопротокола javascript:,
//где позволяет вычислять выражение ради его побочных действий, не отображая
//в броузере вычисленное значение.
//Например, можно использовать оператор void в HTML теге:
//<a href="javascript:void window.open();">Открыть новое окно</a>

//Оператор «запятая» (,) очень прост. Он вычисляет свой левый операнд, вычисля
//ет свой правый операнд и возвращает значение правого операнда, т. е. следую
//щая строка
//i=0, j=1, k=2;
//возвращает значение 2 и практически эквивалентна записи:
//i = 0;
//j = 1;
//k = 2;
//Этот странный оператор полезен лишь в ограниченных случаях; в основном то
//гда, когда требуется вычислить несколько независимых выражений с побочны
//ми эффектами там, где допускается только одно выражение. На практике опера
//тор «запятая» фактически используется только в сочетании с инструкцией for,
//которую мы рассмотрим в главе 6.

var i=5; var z=6; var x=11;

//В JavaScript имеется также способ объединения
//нескольких инструкций в одну инструкцию или в блок инструкций. Это делает
//ся простым заключением любого количества инструкций в фигурные скобки.
//Таким образом, следующие строки рассматриваются как одна инструкция и мо
//гут использоваться везде, где интерпретатор JavaScript требует наличия единст
//венной инструкции:
{
    x = Math.PI;
    cx = Math.cos(x);
    alert("cos(" + x + ") = " + cx);
}


if (username != null) // это тоже нормально, но есть риск запутаться с else
alert("Привет " + username + "\nДобро пожаловать на мою домашнюю страницу.");
else {
username = prompt("Добро пожаловать!\n Как вас зовут?");
alert("Привет " + username);
}

//Обратите внимание: переменной в цикле for/in может быть любое выражение,
//если только результатом его является нечто, подходящее для левой части при
//сваивания. Это выражение вычисляется при каждом вызове тела цикла, т. е. ка
//ждый раз оно может быть разным. Так, скопировать имена всех свойств объекта
//в массив можно следующим образом:
var o = {x:1, y:2, z:3};
var a = new Array();
var i = 0;
for(a[i++] in o) /* пустое тело цикла */;

//Форма инструкции break с меткой требуется только во вложенных циклах или
//в инструкции switch при необходимости выйти из инструкции, не являющейся
//самой внутренней.
//Следующий пример показывает помеченные циклы for и инструкции break
//с метками. Проверьте, удастся ли вам понять, каким будет результат работы это
//го фрагмента:
outerloop:
for(var i = 0; i < 10; i++) {
innerloop:
for(var j = 0; j < 10; j++) {
if (j > 3) break; // Выход из самого внутреннего цикла
if (i == 2) break innerloop; // То же самое
if (i == 4) break outerloop; // Выход из внешнего цикла
document.write("i = " + i + " j = " + j + "<br>");
}
}
document.write("FINAL i = " + i + " j = " + j + "<br>");

//Инструкция continue схожа с инструкцией break. Однако вместо выхода из цикла
//continue запускает новую итерацию цикла. Синтаксис инструкции continue столь
//же прост, как и у инструкции break:
//continue;
//Инструкция continue может также использоваться с меткой:
//continue имя_метки;
//Инструкция continue как в форме без метки, так и с меткой может использовать
//ся только в теле циклов while, do/while, for и for/in. Использование ее в любых
//других местах приводит к синтаксической ошибке.



//Обратите внимание на различия в поведении инструкции continue в циклах while
//и for – цикл while возвращается непосредственно к своему условию, а цикл for
//сначала вычисляет выражение инкремента, а затем возвращается к условию.
//Ранее при обсуждении цикла for я объяснял поведение цикла for в терминах эк
//вивалентного цикла while. Поскольку инструкция continue ведет себя в этих двух
//циклах по разному, точно имитировать цикл for с помощью цикла while невоз
//можно.
//В следующем примере показано использование инструкции continue без метки
//для выхода из текущей итерации цикла в случае ошибки:
for(i = 0; i < data.length; i++) {
if (data[i] == null)
continue; // Продолжение с неопределенными данными невозможно
total += data[i];
}



//В обычной ситуации управление доходит до конца блока try, а затем переходит
//к блоку finally, который выполняет всю необходимую зачистку. Если управле
//ние вышло из блока try из за инструкций return, continue или break, перед пере
//дачей управления в другое место кода исполняется блок finally.
//Если в блоке try возникает исключение и имеется соответствующий блок catch
//для его обработки, управление сначала передается в блок catch, а затем – в блок
//finally. Если отсутствует локальный блок catch, то управление сначала переда
//ется в блок finally, а затем переходит на ближайший внешний блок catch, кото
//рый может обработать исключение.

//Если сам блок finally передает управление с помощью инструкции return, con
//tinue, break или throw или путем вызова метода, генерирующего исключение, не
//законченная команда на передачу управления отменяется и выполняется новая.
//Например, если блок finally генерирует исключение, это исключение заменяет
//любое сгенерированное исключение. Если в блоке finally имеется инструкция
//return, происходит нормальный выход из метода, даже если генерировалось ис
//ключение, которое не было обработано.


//Инструкции try и finally могут использоваться вместе без конструкции catch.
//В этом случае блок finally – это просто код зачистки, который будет гарантиро
//ванно исполнен независимо от наличия в блоке try инструкции break, continue
//118
//Глава 6. Инструкции
//или return. Например, в следующем коде используется инструкция try/finally,
//гарантирующая, что счетчик цикла будет инкрементирован в конце каждой ите
//рации, даже если итерация внезапно прервется инструкцией continue:
var i = 0, total = 0;
while(i < a.length) {
    try {
        if ((typeof a[i] != "number") || isNaN(a[i])) // Если это не число,
        continue; // переходим к следующей итерации цикла.
        total += a[i]; // В противном случае добавляем число к общей сумме.
    }
    finally {
        i++;
        // Всегда увеличиваем i, даже если ранее была инструкция continue.
    }
}


//Это сокращает объем текста программы – больше не надо указывать фрагмент
//frames[1].document.forms[0] перед каждым именем свойства. Этот объект пред
//ставляет собой временную часть цепочки областей видимости и автоматически
//участвует в поиске, когда JavaScript требуется разрешить такой идентифика
//тор, как address.
//Несмотря на удобство этой конструкции в некоторых случаях, ее использование
//не приветствуется. JavaScript код с инструкцией with сложен в оптимизации
//и поэтому может работать медленнее, чем эквивалентный код, написанный без
//нее. Кроме того, определения функций и инициализация переменных в теле ин
//струкции with могут приводить к странным и трудным для понимания результа
//там.1 По этим причинам использовать инструкцию with не рекомендуется.
with(frames[1].document.forms[0]) {
    // Здесь обращаемся к элементам формы непосредственно, например:
    name.value = "";
    address.value = "";
    email.value = "";
}

// Пустая инструкция
//;
//Выполнение пустой инструкции, очевидно, не имеет никакого эффекта и не про
//изводит никаких действий. Можно подумать, что особых причин для ее приме
//нения нет, однако изредка пустая инструкция может быть полезна, когда требу
//ется создать цикл, имеющий пустое тело. Например:
// Инициализация массива a
for(i=0; i < a.length; a[i++] = 0);
//Обратите внимание, что случайное указание точки с запятой после правой круг
//лой скобки в циклах for и while или в инструкции if может привести к неприят
//ным ошибкам, которые сложно обнаружить. Например, следующий фрагмент
//вряд ли делает то, что предполагал его автор:
if ((a == 0) || (b == 0)); // Ой! Эта строка ничего не делает...
o = null;
// а эта строка выполняется всегда.
//Когда пустая инструкция применяется специально, код желательно снабжать
//исчерпывающими комментариями. Например:
for(i=0; i < a.length; a[i++] = 0) /* Пустое тело цикла */ ;


/** Объекты и массивы **/

//Конструктор Object() создает пустой объект, как если бы исполь
//зовался литерал {}.

/** перебор свойств массива. Некоторые предопределенные св-ва а также методы
  в этом не участвуют**/
for(var name in obj) names += name + "\n";
alert(names);


//Для проверки факта наличия того или иного свойства у объекта может использо
//ваться оператор in (см. главу 5). С левой стороны от оператора помещается имя
//свойства в виде строки, с правой стороны – проверяемый объект. Например:
// Если объект o имеет свойство с именем "x", установить его
if ("x" in o) o.x = 1;
//Однако потребность в операторе in возникает не так часто, потому что при обра
//щении к несуществующему свойству возвращается значение undefined. Таким
//образом, указанный фрагмент обычно записывается следующим образом:
// Если свойство x существует и его значение
// не равно undefined, установить его.
if (o.x !== undefined) o.x = 1;
//Обратите внимание: есть вероятность, что свойство фактически существует, но
//еще не определено. Например, если записать такую строку:
//o.x = undefined
//то свойство x будет существовать, но не будет иметь значения. В этом случае
//в первом из показанных фрагментов в свойство x будет записано значение 1,
//во втором – нет.

//Для удаления свойства объекта предназначен оператор delete:
delete book.chapter2;
//Обратите внимание, что при удалении свойства его значение не просто устанав
//ливается в значение undefined; оператор delete действительно удаляет свойство из
//объекта. Цикл for/in демонстрирует это отличие: он перечисляет свойства, кото
//рым было присвоено значение undefined, но не перечисляет удаленные свойства.

/** Свойства и методы класса Object ***/
//Как уже отмечалось, все объекты в JavaScript наследуют свойства и методы
//класса Object. При этом специализированные классы объектов, как, например,
//те, что создаются с помощью конструкторов Date() или RegExp(), определяют соб
//ственные свойства и методы, но все объекты независимо от своего происхожде
//ния помимо всего прочего поддерживают свойства и методы, определенные
//классом Object.
//В JavaScript любой объект имеет свойство constructor, которое ссылается на функ
//цию конструктор, используемую для инициализации объекта. Например, если
//объект d создается с помощью конструктора Date(), то свойство d.constructor ссы
//лается на функцию Date:
var d = new Date( );
d.constructor == Date; // Равно true
//класс Object в дополнение к методу toString()
//определяет метод toLocaleString().
//По умолчанию метод toLocaleString(), определяемый классом Object, 
//никакой локализации не выполняет;
//он всегда возвращает в точности такую же строку, что и toString(). Однако под
//классы могут определять собственные версии метода toLocaleString()

//valueOf() во многом похож на метод toString(), но вызывается, когда ин
//терпретатору JavaScript требуется преобразовать объект в значение какого либо
//элементарного типа, отличного от строки, – обычно в число. 
//По умолчанию метод valueOf() не выполняет ничего, что представляло бы интерес, 
//но некоторые встроенные категории объектовпереопределяют метод valueOf()

//hasOwnProperty() возвращает true, если для объекта определено не унасле
//дованное свойство с именем, указанным в единственном строковом аргументе
//метода. В противном случае он возвращает false. Например:
var o = {};
o.hasOwnProperty("undef");
// false: свойство не определено
o.hasOwnProperty("toString"); // false: toString – это унаследованное свойство
Math.hasOwnProperty("cos"); // true: объект Math имеет свойство cos

//propertyIsEnumerable() возвращает true, если в объекте определено свойст
//во с именем, указанным в единственном строковом аргументе метода, и это свой
//ство может быть перечислено циклом for/in. В противном случае метод возвра
//щает false. Например:
var o = { x:1 };
o.propertyIsEnumerable("x");
// true: свойство существует и является перечислимым
o.propertyIsEnumerable("y");
// false: свойство не существует
o.propertyIsEnumerable("valueOf"); // false: свойство неперечислимое

//isPrototypeOf() возвращает true, если объект, которому принадлежит ме
//тод, является прототипом объекта, передаваемого методу в качестве аргумента.
//В противном случае метод возвращает false. Например:
var o = {};
Object.prototype.isPrototypeOf(o); //true: o.constructor == Object
Object.isPrototypeOf(o); //false
o.isPrototypeOf(Object.prototype); //false
Function.prototype.isPrototypeOf(Object); //true: Object.constructor == Function

//Оператор delete записывает в элемент массива значение undefined, при этом сам
//элемент массива продолжает свое существование. Для удаления элементов так,
//чтобы остающиеся элементы сместились к началу массива, необходимо восполь
//зоваться одним из методов массива. Метод Array.shift() удаляет первый элемент
//массива, метод Array.pop() – последний элемент массива, метод Array.splice() –
//непрерывный диапазон элементов. 

//Свойство length массива доступно как для чтения, так и для записи. Если устано
//вить свойство length в значение, меньшее текущего, массив укорачивается до но
//вой длины; любые элементы, не попадающие в новый диапазон индексов, отбра
//сываются, и их значения теряются.
var a = new Array(1,2,3);// a[0] = 1, a[1] = 2, a[2] = 3
a.reverse(); // теперь a[0] = 3, a[1] = 2, a[2] = 1
var s = a.join(); // s == "3,2,1"


var a = [33, 4, 1111, 222]; //Алфавитный порядок: 1111, 222, 33, 4
a.sort(); //Числовой порядок: 4, 33, 222, 1111
a.sort(function(a,b) { //Возвращает значение < 0, 0, или > 0 в зависимости от порядка сортировки a и b
return a b;
});

//Метод Array.concat() создает и возвращает новый массив, содержащий элементы
//исходного массива, для которого был вызван метод concat(), последовательно до
//полненный значениями всех аргументов, переданных методу concat(). Если ка
//кой либо из этих аргументов сам является массивом, в результирующий массив
//добавляются его элементы

var a = [1,2,3]; 
a.concat(4, 5); //[1,2,3,4,5] 
a.concat([4,5]);//[1,2,3,4,5]
a.concat([4,5],[6,7]); //[1,2,3,4,5,6,7]
a.concat(4, [5,[6,7]]); //[1,2,3,4,5,[6,7]]

//Array.slice() возвращает фрагмент, или подмассив, указанного массива.
var a = [1,2,3,4,5];
a.slice(0,3); //[1,2,3]
a.slice(3); //[4,5]
a.slice(1, 1); //[2,3,4]
a.slice( 3, 2); //[3]

//Array.splice() – это универсальный метод для вставки или удаления эле
//ментов массива. Он изменяет массив на месте, а не возвращает новый массив,
//как это делают методы slice() и concat()
//Метод splice() возвращает массив удаленных элементов или (если
//ни один из элементов не был удален) пустой массив. Например:
var a = [1,2,3,4,5,6,7,8];
a.splice(4); // Возвращает [5,6,7,8]; a = [1,2,3,4]
a.splice(1,2); // Возвращает [2,3]; a = [1,4]
a.splice(1,1); // Возвращает [4]; a = [1]

//Первые два аргумента splice() задают элементы массива, подлежащие удале
//нию. За этими аргументами может следовать любое количество дополнительных
//аргументов, задающих элементы, которые будут вставлены в массив, начиная
//с позиции, заданной первым аргументом. Например:
var a = [1,2,3,4,5];
a.splice(2,0,'a','b'); // Возвращает []; a = [1,2,'a','b',3,4,5]
a.splice(2,2,[1,2],3); // Возвращает ['a','b']; a равно [1,2,[1,2],3,3,4,5]

//У массива, как и у любого другого объекта в JavaScript, имеется метод toString().

[1,2,3].toString(); // Получается '1,2,3'
["a", "b", "c"].toString(); // Получается 'a,b,c'
[1, [2,'c']].toString(); // Получается '1,2,c'
//Метод toLocaleString() – это локализованная версия toString(). Каждый элемент
//массива преобразуется в строку вызовом метода toLocaleString() элемента, а за
//тем результирующие строки конкатенируются с использованием специфическо
//го для региона (и определенного реализацией) разделителя.

//Броузер Firefox Mozilla 1.5 включает в себя новую версию JavaScript 1.6, в кото
//рую был добавлен набор дополнительных методов массивов, получивших назва
//ние дополнений к массивам (array extras). Из наиболее примечательных можно
//назвать методы indexOf() и lastIndexOf(), позволяющие быстро отыскать в масси
//ве заданное значение (описание аналогичного им метода String.indexOf() можно
//найти в третьей части книги). Кроме того, в состав набора входят еще несколько
//интересных методов: метод forEach() вызывает указанную функцию для каждо
//го элемента в массиве; метод map() возвращает массив, полученный в результате
//передачи всех элементов массива указанной функции; метод filter() возвраща
//ет массив элементов, для которых заданная функция возвратила значение true.

/** Функции **/
function hypotenuse(a, b) {
    function square(x) { return x*x; }
        return Math.sqrt(square(a) + square(b));
}
//Вложенные функции могут определяться только в коде функций верхнего уров
//ня. Это значит, что определения функций не могут находиться, например, внут
//ри циклов или условных инструкций.1 Обратите внимание: эти ограничения
//распространяются только на объявления функций с помощью инструкции func
//tion. Функциональные литералы (которые описываются в следующем разделе)
//могут присутствовать внутри любых выражений.

function f(x) { return x*x; } // инструкция function
var f = function(x) { return x*x; }; // функциональный литерал

//Функциональные литералы создают неименованные функции, но синтаксис до
//пускает указание имени функции, что может пригодиться при написании ре
//курсивных функций, вызывающих самих себя. Например:
var f = function fact(x) { if (x <= 1) return 1; else return x*fact(x 1); };

//В теле функции идентификатор arguments всегда имеет особый смысл; arguments –
//это специальное свойство объекта вызова, ссылающееся на объект, известный
//как объект Arguments. Объект Arguments – это нечто вроде массива (см. раздел 7.8),
//позволяющего извлекать переданные функции значения по номеру, а не по име
//ни. Объект Arguments также определяет дополнительное свойство callee

//arguments фактически не является массивом – это объект
//Arguments. В каждом объекте Arguments имеются пронумерованные элементы мас
//сива и свойство length, но с технической точки зрения – это не массив. Лучше рас
//сматривать его как объект, имеющий некоторые пронумерованные свойства.

//Помимо элементов своего массива объект Arguments определяет свойство callee,
//ссылающееся на исполняемую в данный момент функцию. 
//Его можно использовать, например, для рекурсивного вызова неименованных функций. 

function(x) {
    if (x <= 1) return 1;
    return x * arguments.callee(x - 1);
}

//У функций даже не обязательно должны быть имена, например в случае при
//сваивании их элементам массива:
var a = new Array(3);
a[0] = function(x) { return x*x; }
a[1] = 20;
a[2] = a[0](a[1]); // a[2] содержит 400


var o = new Object;
o.square = function(x) { return x*x; }; // функциональный литерал
y = o.square(16);// y равно 256

// Эта функция принимает имя оператора, отыскивает оператор в объекте,
// а затем вызывает его для переданных операндов. Обратите внимание
// на синтаксис вызова функции оператора.
function operate2(op_name, operand1, operand2)
{
    if (typeof operators[op_name] == "function")
        return operators[op_name](operand1, operand2);
    else throw "неизвестный оператор";
}
// Вот так мы можем вызвать эту функцию для вычисления значения
// ("hello" + " " + "world"):
var j = operate2("add", "hello", operate2("add", " ", "world"));
// Используем предопределенную функцию Math.pow():
var k = operate2("pow", 10, 2);

//Как мы видели, в теле функции свойство length массива arguments определяет ко
//личество аргументов, переданных этой функции. Однако свойство length самой
//функции имеет другой смысл. Это доступное только для чтения свойство возвра
//щает количество аргументов, которое функция ожидает получить, т. е. объяв
//ленных в ее списке параметров. 


//В следующем фрагменте определяется функция с именем check(), получающая
//массив аргументов от другой функции. Она сравнивает свойство arguments.length
//со свойством Function.length (доступным как arguments.callee.length) и проверя
//ет, передано ли функции столько аргументов, сколько она ожидает. Если это не
//так, генерируется исключение. За функцией check() следует тестовая функция
//f(), демонстрирующая порядок вызова функции check():
function check(args) {
    var actual = args.length;
    // Фактическое число аргументов
    var expected = args.callee.length; // Ожидаемое число аргументов
    if (actual != expected) {
    // Если числа не совпадают, генерируется исключение
    throw new Error("неверное число аргументов: ожидается: " +
    expected + "; фактически передано " + actual);
    }
}

function f(x, y, z) {
    // Проверяем, соответствует ли ожидаемому фактическое количество
    // аргументов. Если не соответствует, генерируем исключение
    check(arguments);
    // Теперь выполняем оставшуюся часть функции обычным образом

    return x + y + z;
}

/** 8.6.2. Свойство prototype **/
//Любая функция имеет свойство prototype, ссылающееся на предопределенный
//объект прототип. Этот объект, который вступает в игру, когда функция ис
//пользуется в качестве конструктора с оператором new, играет важную роль в про
//цессе определения новых типов объектов.

/** 8.6.3. Определение собственных свойств функций **/

// Создаем и инициализируем "статическую" переменную.
// Объявления функций обрабатываются до исполнения кода,
// поэтому мы действительно можем выполнить это присваивание
// до объявления функции
uniqueInteger.counter = 0;
// Сама функция. Она возвращает разные значения при каждом
// вызове и использует собственное "статическое" свойство
// для отслеживания последнего возвращенного значения.
function uniqueInteger() {
// Наращиваем и возвращаем значение "статической" переменной
return uniqueInteger.counter++;
}

/** 8.6.4. Методы apply и call() **/
//В ECMAScript есть два метода, определенные для всех функций, – call() и apply().
//Эти методы позволяют вызывать функцию так, будто она является методом не
//которого объекта. Первый аргумент методов call() и apply() – это объект, для
//которого выполняется функция; этот аргумент становится значением ключевого
//слова this в теле функции. Все оставшиеся аргументы call() – это значения, пере
//даваемые вызываемой функции. Так, чтобы передать функции f() два числа и вы
//звать ее как метод объекта o, можно использовать следующий прием:
f.call(o, 1, 2);

//Это аналогично следующим строкам программы:
o.m = f;
o.m(1,2);
delete o.m;

//Метод apply() похож на метод call(), за исключением того, что передаваемые
//функции аргументы задаются в виде массива:
//f.apply(o, [1,2]);
//Например, чтобы найти наибольшее число в массиве чисел, можно вызвать ме
//тод apply() для передачи элементов массива функции Math.max():
var biggest = Math.max.apply(null, array_of_numbers);

/**Функции для работы с функциями**/
// Возвращает самостоятельную функцию, которая в свою очередь вызывает
// функцию "f" как метод объекта "o". Эта функция может использоваться,
// когда возникает необходимость передать в функцию метод.
// Если не связать метод с объектом, ассоциация будет утрачена, и метод,
// переданный функции, будет вызван как обычная функция.
function bindMethod(/* объект */ o, /* функция */ f) {
    return function() { return f.apply(o, arguments) }
}
// Возвращает самостоятельную функцию, которая в свою очередь вызывает
// функцию "f" с заданными аргументами и добавляет дополнительные
// аргументы, передаваемые возвращаемой функции.
// (Этот прием иногда называется "currying".)
function bindArguments(/* функция */ f /*, начальные аргументы... */) {
    var boundArgs = arguments;
    return function() {
    // Создать массив аргументов. Он будет начинаться с аргументов,
    // определенных ранее, и заканчиваться аргументами, переданными сейчас
    var args = [];
    for(var i = 1; i < boundArgs.length; i++) args.push(boundArgs[i]);
    for(var i = 0; i < arguments.length; i++) args.push(arguments[i]);
        // Теперь вызвать функцию с новым списком аргументов
        return f.apply(this, args);
    }
}

/**ЗАМЫКАНИЯ**/
// При каждом вызове возвращает разные значения
uniqueID = function() {
if (!arguments.callee.id) arguments.callee.id = 0;
return arguments.callee.id++;
};
//Проблема заключается в том, что свойство uniqueID.id доступно за пределами
//функции и может быть установлено в значение 0, вследствие чего будет наруше
//но соглашение, по которому функция обязуется никогда не возвращать одно и то
//же значение дважды. Для решения этой проблемы можно сохранять значение
//в замыкании, доступ к которому будет иметь только эта функция:
uniqueID = (function() { // Значение сохраняется в объекте вызова функции
var id = 0;
// Это частная переменная, сохраняющая свое
// значение между вызовами функции
// Внешняя функция возвращает вложенную функцию, которая имеет доступ
// к этому значению. Эта вложенная функция сохраняется
// в переменной uniqueID выше.
return function() { return id++; }; // Вернуть и увеличить
})(); // Вызов внешней функции после ее определения.


var y = "глобальная";
function constructFunction() {
var y = "локальная";
return new Function("return y"); // Не сохраняет локальный контекст!
}
// Следующая строка выведет слово "глобальная", потому что функция,
// созданная конструктором Function(), не использует локальный контекст.
// Если функция была определена как литерал,
// эта строка вывела бы слово "локальная".
alert(constructFunction()()); // Выводит слово "глобальная"
var t /=2;
var x = ^+3;


/**  COOKIE **/
//Помимо имени и значения каждый cookie имеет четыре необязательных атрибу
//та, управляющих временем его жизни, видимостью и безопасностью. По умол
//чанию cookies являются временными – их значения сохраняются на период се
//анса веб броузера и теряются при закрытии сеанса пользователем.
//Чтобы cookie
//сохранялся после окончания сеанса, необходимо сообщить броузеру, как долго
//он должен храниться. Изначально для этого использовался атрибут expires, ука
//зывающий дату окончания действия cookie. И хотя этот атрибут по прежнему
//может применяться, он начинает вытесняться другим атрибутом – max age, кото
//рый определяет срок хранения cookie в секундах. Установка значения любого из
//этих атрибутов заставляет броузер сохранить cookie в локальном файле, чтобы
//он мог быть прочитан при следующем посещении пользователем веб страницы.
//После того как будет достигнута дата окончания действия или истечет период
//max age, броузер автоматически удалит cookie файл.

//Еще один немаловажный атрибут cookie, path, задает веб страницы, с которыми
//связан cookie. По умолчанию cookie связывается с создавшей его веб страницей
//и доступен этой же странице, а также любой другой странице из того же каталога
//или любых его подкаталогов. Если, например, веб страница http://www.examp
//le.com/catalog/index.html создает cookie, то этот cookie будет также видим страни
//цам http://www.example.com/catalog/order.html и http://www.example.com/cata
//log/widgets/index.html, но не видим странице http://www.example.com/about.html.

//для cookie файла задается значение path.
//Тогда любая страница того же веб сервера, содержащая указанное значение в сво
//ем URL, сможет использовать cookie файл. Например, если для cookie, установ
//ленного страницей http://www.example.com/catalog/widgets/index.html, для атри
//бута path задано значение "/catalog", этот cookie будет также виден для страницы
//http://www.example.com/catalog/order.html. А если атрибут path установлен в "/",
//то cookie файл будет виден для любой страницы на веб сервере www.example.com.

//По умолчанию cookies доступны только страницам, загружаемым с того веб серве
//ра, который их установил. Однако большим веб сайтам может потребоваться воз
//можность совместного использования cookies несколькими веб серверами. Напри
//мер, серверу order.example.com может потребоваться прочитать значения cookie,
//установленного сервером catalog.example.com. В этой ситуации поможет третий ат
//рибут cookie файла – domain. Если cookie, созданный страницей с сервера catalog.ex
//ample.com, установил свой атрибут path, равным "/", а атрибут domain – равным
//".example.com", этот cookie будет доступен всем веб страницам серверов catalog.ex
//ample.com, orders.example.com и любых других серверов в домене example.com.
//Если атрибут domain для cookie не установлен, значением по умолчанию будет
//имя веб сервера, на котором находится страница. Обратите внимание, что нельзя
//сделать так, чтобы домен cookie файла отличался от домена вашего сервера.
//Последний атрибут cookie – это логический атрибут с именем secure, определяю
//щий, как значения cookie файла передаются по сети. По умолчанию cookie не за
//щищен, т. е. передается по обычному незащищенному HTTP соединению. Одна
//ко если cookie помечен как защищенный, он передается, только когда обмен ме
//жду броузером и сервером организован по протоколу HTTPS или другому защи
//щенному протоколу.

//Cледует проверить, не отключен ли режим их сохранения? В большинстве броузеров 
//это можно сделать, проверив свойство navigator.cookieEnabled. Если оно содержит
//значение true, значит
//работа с cookie разрешена, а если false – запрещена (хотя при этом могут быть
//разрешены временные cookie файлы, срок жизни которых ограничивается про
//должительностью сеанса работы броузера). Это свойство не является стандарт
//ным, поэтому если сценарий вдруг обнаружит, что оно не определено, придется
//проверить, поддерживаются ли cookies, попытавшись записать, прочитать и уда
//лить тестовый cookie файл. 

//Чтобы связать временное значение cookie файла с текущим документом, доста
//точно установить свойство cookie равным строке следующего формата:
//имя=значение
//Например:
//document.cookie = "version=" + encodeURIComponent(document.lastModified);


//При следующем чтении свойства cookie сохраненная пара «имя–значение» будет
//включена в список cookie файлов документа. Значения cookie не могут содер
//жать точки с запятой, запятые или символы разделители. По этой причине для
//кодирования значения перед сохранением его в cookie файле, возможно, потре
//буется использовать JavaScript функцию encodeURIComponent(). В этом случае при
//чтении значения cookie файла надо будет вызвать соответствующую функцию
//decodeURIComponent(). (Нередко можно встретить программный код, использую
//щий для тех же целей устаревшие функции escape() и unescape().)

// Прочитать свойство cookie. В результате будут получены все cookies данного документа.

var allcookies = document.cookie;
// Отыскать начало cookie файла с именем "version"
var pos = allcookies.indexOf("version=");
// Если cookie с данным именем найден, извлечь и использовать его значение
if (pos != 1) {
var start = pos + 8;
// Начало значения cookie
var end = allcookies.indexOf(";", start);
// Конец значения cookie
if (end == 1) end = allcookies.length;
    var value = allcookies.substring(start, end); // Извлекаем значение
    value = decodeURIComponent (value);

if(value != document.lastModified)
    alert("Документ был изменен с момента вашего последнего посещения");
}
//Теперь, получив значение cookie файла, мы можем его использовать.
//В данном случае значение было установлено равным дате изменения
//документа, поэтому мы можем использовать это значение, чтобы узнать,
//был ли документ изменен с момента последнего посещения пользователем.

//Обратите внимание: строка, полученная при чтении значения свойства cookie,
//не содержит какой либо информации о различных атрибутах cookie файла.
//Свойство cookie позволяет установить эти атрибуты, но не дает возможности про
//читать их.

//Конструктор Cookie() читает значение cookie с заданным именем. 
//Метод store() записывает данные в этот cookie, при этом устанавливаются значения 
//атрибутов, определяющих срокжизни, путь и домен, а метод remove() удаляет cookie, 
//записывая значение 0 в атрибут max age.

//
//<script src="Cookie.js"></script>
//<script>
// Создать cookie, который будет использоваться для сохранения
// информации о состоянии данной веб страницы.
var cookie = new Cookie("vistordata");

if
//Глава 19. Cookies и механизм сохранения данных на стороне клиента
//Сначала попытаться прочитать данные, хранящиеся в cookie.
//Если он еще не существует (или не содержит требуемые данные),
//запросить данные у пользователя
(!cookie.name || !cookie.color) {
cookie.name = prompt("Введите ваше имя:", "");
cookie.color = prompt("Какой цвет вы предпочитаете:", "");
}
// Запомнить число посещений страницы пользователем
if (!cookie.visits) cookie.visits = 1;
else cookie.visits++;
// Сохранить данные в cookie, куда включается счетчик числа посещений.
// Определить срок жизни cookie в 10 дней. Поскольку атрибут path
// не определяется, cookie будет доступен всем веб страницам того же
// каталога и вложенных каталогов. Поэтому необходимо гарантировать,
// что имя cookie "visitordata" будет уникальным для всех этих страниц.
cookie.store(10);
// Теперь можно воспользоваться данными, полученными из cookie
// (или от пользователя), чтобы приветствовать пользователя по имени,
// подсветив приветствие цветом, который предпочитает пользователь.
document.write('<h1 style="color:' + cookie.color + '">' +
'Добро пожаловать, ' + cookie.name + '!' + '</h1>' +
'<p>Вы посетили нас ' + cookie.visits + ' раз.' +
'<button onclick="window.cookie.remove();">Забыть обо мне </button>');




